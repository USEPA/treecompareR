---
title: "JStatSoft"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{JStatSoft}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
#library(treecompareR)
devtools::load_all()
library(kableExtra)
```

# Abstract

This paper presents the **treecompareR** package for `R`, which provides tools for reproducible visualizations of data through the use of taxonomies. The package builds on developments from **gplot2**, **ggtree** to provide visualizations tailored for use with taxonomic classification data. It also provides a pipeline for gathering chemical classification data using **classyfireR** and the [Hazard Comparison Dashboard](https://hazard.sciencedataexperts.com/#/). Additionally, it provides tools that leverage developments in network analysis to compare data sets. While designed specifically for chemical classification objectives using [ClassyFire](http://classyfire.wishartlab.com/), **treecompareR** provides tools for use with more general taxonomies.


# Introduction

Classification of objects has been a source of much development of organizational structures across various fields of science. Organizing objects into a coherent structure helps one to understand how these objects relate to each other and can lead to the discovery of connections between various sets of objects. How one organizes the objects may depend on underlying attributes that the objects possess. 

Ontologies provide a framework for comparing objects through a variety of different relation types. These relation types create a network structure that can be studied using graph theory techniques. One of the more actively developed ontologies in recent science is the Gene Ontology, which aims to develop a computation model of biological systems. The ontology considers the three domains defined as molecular function, cellular component, and biological process with relationships between terms within each of these domains and between the three domains as well. Using these domains, the ontology describes genes and how they relate to various areas of interest in contemporary biological research.  

Within the universe of ontologies sits the set of organizing structures known as taxonomies. Restricting the attention to taxonomies, one can focus specifically on the "is a" relation, e.g. "a dog (*canis familiaris*) is a *canis*" and study how objects relate to one another under this specific relationship scheme. One well known example of this organizational structure in use is the Linnaean system for classifying life, sometimes referred to as the "tree of life". As a taxonomy, the organizational structure is given by a tree, which consequently lends itself to analysis using tree-based techniques from graph theory.

In 2016, the [ClassyFire](http://classyfire.wishartlab.com/) tool was introduced, in the work of [Djoumbou et al](https://jcheminf.biomedcentral.com/articles/10.1186/s13321-016-0174-y). This work presented a chemical ontology, ChemOnt, consisting of 4825 classification labels. These labels are organized in a taxonomy structure with pairs of distinct labels either satisfying a simple "is a" relation or not. The ClassyFire tool takes in chemical identifiers such as InChIKey or SMILES strings and provides a classification of the chemical within the taxonomy. In this manner, one can examine a data set consisting of chemical data from the viewpoint of where the chemicals lie within the ChemOnt taxonomy structure.

In the study of cheminformatics, machine-learning models such as Quantitative structure-activity relationship (QSARs) are constructed to link physical and structural properties with biological interactions. For these models to produce accurate and reliable predictions, an analysis of the training data and targeted use data is essential. This consideration of the domain of applicability of the model is important for determining when the trained model's predictions can be considered reliable given an input chemical. In many cases, this analysis can be carried out using model descriptors, for example by using structural descriptors of the molecules used for training the model. However, while descriptors may accurately describe the domain of applicability, they often can be hard to interpret and they do not necessarily lend themselves that well to visualization.

Understanding and overcoming these issues in one's ability to interpret the data are especially important when comparing pairs of data sets, such as training and test sets or training and prediction sets. While it may be feasible to examine how each individual data set is characterized by model descriptors, how they overlap requires additional consideration. Is the overlap broad or does it focus on specific areas? Are there gaps between the training data and prediction data that may reduce the confidence users have in model predictions? Answering these and other questions addresses concerns of model applicability to data sets in general and how the model can be improved regarding gaps in training data compared to prediction or test data. 

One approach to addressing these naturally arising concerns is through visualizations that can increase the user's ability to interpret the data sets. Since the ClassyFire ChemOnt ontology is organized in a taxonomy structure, one can leverage the tree structure not only for quantitative analysis but also through the use of tree visualizations. These visualizations can reveal the extent to which there are overlaps within the data and the degree of such overlaps. The diagrams also show very clearly when there are gaps between the data sets and broad coverage, or lack thereof, within the chemical universe as it is represented by ChemOnt.

However, such visualizations are limited in terms of what is currently available. One may use the [ggplot2](https://ggplot2.tidyverse.org/) R package to visualize statistics based on the taxonomic information corresponding to classifications of a data set. But **ggplot2** is a very broad package and not designed for handling chemical classification data in particular. Since the ChemOnt taxonomy is given by a tree structure, one can use tree visualization packages such as [ggtree](https://bioconductor.org/packages/release/bioc/html/ggtree.html#:~:text=an%20R%20package%20for%20visualization%20of%20tree%20and%20annotation%20data&text='ggtree'%20extends%20the%20'ggplot2,structures%20with%20their%20annotation%20data.) to visualize this structure. However, the **ggtree** package was designed with phylogenetic trees in mind, which are generally presented as rooted binary trees (possibly with additional data). The ChemOnt ontology is neither a binary tree nor does it carry additional explicit data, so **ggtree** is again a very broad approach to this.

We present the package **treecompareR** as a solution to the specific needs of creating a pipeline to classify chemicals in a data set, visualize the chemical space they represent, and compare the data sets from the point of view of chemical space. We introduce the package through a case study analyzing two specific data sets. We characterize two data sets, BIOSOLIDS_2022_05_10 and USGSWATER_2022_05_17, that were collected from the CompTox Chemical Dashboard. The BIOSOLIDS_2022_05_10 data describe chemicals detected in biosolids, as reported by three national sewage sludge surveys and eight biennial reviews, while the USGSWATER_2022_05_17 data describe chemicals found in water by the USGS.  

We are interested in studying these two data sets together for a variety of reasons. The presence of chemicals detected in water is important information to consider when determining risk assessment for human and ecological health. Not only does this indicate what chemicals human activity contributes to water, but also what to expect to be present in water that is used in commercial, industrial, and residential settings. Chemicals detected in biosolids indicate both the chemicals that are already present in water in before being used, and the chemicals that human activity contributes to water and persists through the treatment process of waste water. By examining these two sets, we can get a better idea of which chemicals are introduced directly through human activity and use, and which chemicals are already in the background water as well as those that may be successfully removed from the water and captured within the biosolids. 

# Example Data

In this paper, we use the `chemical_list_BIOSOLIDS_2022_05_10` and `chemical_list_USGSWATER_2022_05_17` data sets, which are available for download from the US Environmental Protection Agency's [CompTox Dashboard Chemical List](https://comptox.epa.gov/dashboard/chemical-lists) website. Note, the names of these data sets as listed on the CompTox Dashboard Chemical List are *BIOSOLIDS2021* and *USGSWATER*, respectively.

These data sets include a list of chemicals, relevant identifiers such as `DTXSID`, `InChIKey`, `SMILES`, physical data such as `MOLECULAR_FORMULA`, `AVERAGE_MASS`, `MONOISOTOPIC_MASS`, and publication and quality data such as `PUBCHEM_DATA_SOURCES` and `QC_Level`. 

Before we start comparing these data sets, we must provide each chemical in each data set classification data from ClassyFire. To do this, we use the classification pipeline in `treecompareR`, construct a tree that encodes the taxonomy used in this classification scheme, and use this tree for data analysis and to create visualizations.

To achieve these aims, we use the [ClassyFire](http://classyfire.wishartlab.com/) tool. ClassyFire uses the ChemOnt ontology, consisting of 4825 labels over 11 levels of classification, to classify chemicals. The ontology is given a taxonomic structure, that of a tree, with each label given a unique parent label and potentially having several children labels. This relationship data between labels can be found at [ChemOnt Taxnodes](http://classyfire.wishartlab.com/tax_nodes.json) in JSON format. To construct a tree that encodes this structure, we must first download this data or use the file `chemont_parent_child.rda` from **treecompareR** with column names `Name`, `ID`, `Parent_ID`. With this data in hand, we construct the tree as a `phylo` object as follows.

```{r chemont-tree, fig.cap="chemont-tree"}
options(width = 80)
chemont_taxonomy <- generate_tree(dataframe = chemont_parent_child)
str(chemont_taxonomy[[1]], width = 60)
str(chemont_taxonomy[[2]], width = 60)
```

The output of the `generate_taxonomy()` function is a list of two objects, the `phlyo` object representing the tree, and a data frame used in creating the `phylo` object. Observe the structure of these in Figure \@ref(fig:chemont-tree). 

The `phylo` object itself is a list, describing the edges of the tree, the number of internal nodes, the tip labels and internal node labels, and a set of edge lengths generated in the construction of the tree. One thing to note is that the edge lengths are artificial and are only used to speed up the creation of the tree, but do not represent any actual data corresponding to the tree. However, we retain the edge lengths as they are useful in creating visualizations.

The data frame includes the name of each label, its ID from the `chemont_parent_child.rda` file, its parent (aside from the root `Chemical entities`), internally generated id_number, parent_id_number, a string representing the path from the root to the label, and plotHeight, which is internally generated to speed up the construction of the tree but does not represent any actual data.

To construct a tree for other taxonomies, one can enter in a path to a JSON file or an enter in a data frame. The JSON file must have three columns, the first the name of the label, the second its ID, and the third the parent ID. For the root, the parent ID should be `NA`. If the data is in the form of a data frame, it must be organized in the same way the JSON file is, with column names given by `Name`, `ID`, and `Parent_ID` in that order.

Next, we use the ClassyFire tool to provide classifications for the chemicals in our data sets. To simplify this process, **treecompareR** has a data pipeline that allows for programmatic acquisition of this data. It leverages the package [classyfireR](https://github.com/aberHRML/classyfireR) for accessing the ClassyFire API. In addition, for chemicals missing certain identifying data such as InChIKey or SMILES string data, **treecompareR** also includes functions to retrieve this data from the Hazard Comparison Dashboard. We demonstrate these below in \@ref(fig:clean-na-space-biosolids) and \@ref(fig:clean-na-space-usgs).

```{r clean-na-space-biosolids, fig.cap = "clean-na-space-biosolids", message = FALSE, results = 'hide', eval = FALSE}
biosolids <- data.table(chemical_list_biosolids_2022_05_10)
biosolids[INCHIKEY == '' & CASRN != '', INCHIKEY := {
  temp = ''
  attempt <- get_chemical_identifiers(unique(CASRN))
  if (!is.null(attempt)){
    temp = attempt@meta$inchikey
  }
  ifelse(is.null(temp), '', temp)
}, by = CASRN]
biosolids[SMILES == '' & CASRN != '', SMILES := {
  temp = ''
  attempt <- get_chemical_identifiers(unique(CASRN))
  if (!is.null(attempt)){
    temp = attempt@meta$smiles
  }
  ifelse(is.null(temp), '', temp)
}, by = CASRN]

biosolids_classified <- classify_datatable(biosolids)
biosolids_classified <- classify_by_smiles(biosolids_classified)
```

```{r, echo = FALSE, message = FALSE}
biosolids_classified <- readRDS("C:/Users/pkruse/treecomparer paper/biosolids_classified.rds")
```


We first identify those chemicals that have a value in the CASRN column and are missing a value in the INCHIKEY column. We try to retrieve the missing INCHIKEY information from the Hazard Comparison Dashboard using the `get_chemical_identifiers()` function. We then examine any chemicals missing a value in the SMILES column that have a CASRN value and again use the `get_chemical_identifiers()` function to retrieve the missing data. This is in preparation for applying the functions `classify_datatable()` and `classify_by_smiles()` to the data.table of chemicals for retrieving chemical classification data.

The function `classify_datatable()` uses the InChIKey data, when present, for a first pass in accessing ChemOnt classifications. For those chemicals that remain unclassified, the function `classify_by_smiles()` uses SMILES strings, when present, for a second pass in accessing ChemOnt classifications. It is important to note that `classify_by_smiles()` requires as an input a data.table that is the output of `classify_datatable()`, and the function `classify_datatable()` requires as an input a data.table that has the columns `PREFERRED_NAME`, `CASRN`, and `INCHIKEY`. The order matters, so always apply `classify_datatable()` to a data.table first and then feed the output to `classify_by_smiles()`. 

We complete the same process on the data set `chemical_list_USGSWATER_2022_05_17` for retrieving classification data.

```{r clean-na-space-usgs, fig.cap = "clean-na-space-usgs", message = FALSE, results = 'hide', eval = FALSE}
usgswater <- data.table(chemical_list_USGSWATER_2022_05_17)
usgswater[is.na(INCHIKEY) & !is.na(CASRN), INCHIKEY := {
  temp = ''
  attempt <- get_chemical_identifiers(unique(CASRN))
  if (!is.null(attempt)){
    temp = attempt@meta$inchikey
  }
  ifelse(is.null(temp), '', temp)
}, by = CASRN]
usgswater[is.na(SMILES) & !is.na(CASRN), SMILES := {
  temp = ''
  attempt <- get_chemical_identifiers(unique(CASRN))
  if (!is.null(attempt)){
    temp = attempt@meta$smiles
  }
  ifelse(is.null(temp), '', temp)
}, by = CASRN]

usgswater_classified <- classify_datatable(usgswater)
usgswater_classified <- classify_by_smiles(usgswater_classified)
```

```{r, echo = FALSE, message = FALSE}
usgswater_classified <- readRDS("C:/Users/pkruse/treecomparer paper/usgswater_classified.rds")
```

Now, let us examine these two data sets. Notice that there are 11 columns of ChemOnt data, starting with `kingdom`, `superclass`, and continuing through to `level11`, denoting the taxonomic levels of the ChemOnt ontology. For a given row, not all of these columns will be filled with labels, and the last non-empty column denotes the most specific classification label associated with the chemical represented by the row. While there are many columns in this table, we will only display a subset of these, namely `PREFERRED_NAME`, `INCHIKEY`, `AVERAGE_MASS`, `kingdom`, `superclass`, `class`, `subclass`, `level5`, to illustrate some of the important features in the data set.

```{r display_classifications}
kableExtra::kbl(biosolids_classified[1:5, c('PREFERRED_NAME', 'INCHIKEY', 
                                         'AVERAGE_MASS', 'kingdom',
                                         'superclass', 'class', 
                                         'subclass', 'level5')]) %>%
  kableExtra::kable_styling(full_width = FALSE, bootstrap_options = 'striped', font_size = 9)
#  kbl() %>%
#  kable_styling(bootstrap_options = c("striped", "hover")) %>%
#  kable_classic()

kableExtra::kbl(usgswater_classified[1:5, c('PREFERRED_NAME', 'INCHIKEY',
                                         'AVERAGE_MASS', 'kingdom',
                                         'superclass', 'class',
                                         'subclass', 'level5')])  %>%
  kableExtra::kable_styling(full_width = FALSE, bootstrap_options = 'striped', font_size = 9)
#  kbl() %>%
#  kable_styling(bootstrap_options = c("striped", "hover")) %>%
#  kable_classic()
```
Observe that in the first table, the third row does not have an entry for subclass. This means that the most specific taxonomic label associated to the chemical `4-epi-Oxytetracycline` is given by `Tetracyclines`, at the class level. Similarly, in the second table, the first row does not have an entry for the subclass column, and thus the most specific taxonomic classification label for the chemical `S-Methyl N-hydroxythioacetimidate` is `Sulfenyl compounds` at the class level.

To gain an understanding of these data sets and the chemical classifications they represent, we first look at the number of labels each data set represents, broken down through taxonomic level. The function `label_bars()` takes in a single data.table or a (possibly named) list of data.tables and constructs histograms of label numbers faceted by data set and by taxonomic level.

```{r label-bars, fig.cap="label-bars",  fig.align='center', fig.dim=c(6,4)}
data_list <- list(biosolids_classified, 
                  usgswater_classified)
names(data_list) <- c('Biosolids', 'USGS Water')
label_bars(data_list)
```

From these diagrams in \@ref(fig:label-bars), we see that the distribution of numbers of labels across taxonomic levels is relatively similar for each data set, though in general the `chemical_list_USGSWATER_2022_05_17` data has more labels than the `chemical_list_BIOSOLIDS_2022_05_10` data at each level. However, this does not give us a sense of how these labels spread through chemical space as defined by ChemOnt nor does it characterize the overlap between the classifications of these data sets. To investigate these aspects of chemical space coverage further, we use tree-based visualizations.

# Tree visualizations

The tree visualizations developed in treecompareR rely heavily on the **ggtree** package, which was designed with visualization of phylogenetic trees in mind. The **ggtree** package extends the widely used **ggplot2** package, greatly broadening the variety and scope of tree visualizations available for use.

We first display the ChemOnt tree, the taxonomy structure of the ChemOnt ontology, in a circular layout format.


```{r chemont-tree-plot, fig.cap="chemont-tree-plot"}
ggtree(chemont_tree) + layout_circular()
```

The diagram \@ref(fig:chemont-tree-plot) illustrates the scope of the taxonomy structure of the ChemOnt ontology. From this diagram we create visualizations that highlight the areas of chemical space each data set represents. This ChemOnt tree diagram displays a tree with 3612 tips and 1213 internal nodes (including the root of the tree). As one can easily observe, this creates a dense tree visualization that requires additional attention to be of greater use.

We first examine which parts of this tree are given by classifications of chemicals in each data set. To do this, we use the function `display_subtree()`. This function takes in a data.table with classification data and returns a tree diagram highlighting membership for each node and tip of the full ChemOnt tree. Branches and nodes in the tree are highlighted different colors depending on whether they are included in the set of classification labels of the data.table. In this example we also display the tip labels.

```{r subtree-plots, fig.cap="subtree-plots",  fig.align='center', fig.dim=c(6,4)}
display_subtree(data_1 = biosolids_classified, 
                name_1 = 'Biosolids')
display_subtree(data_1 = usgswater_classified, 
                name_1 = 'USGS Water')
```

In the two diagrams of \@ref(fig:subtree-plots), we observe that the labels and branches represented by classifications from each data set are shaded red while labels and branches not present in the classifications are shaded grey. This helps illustrate where in chemical space these classification labels are located. While it is possible to toggle between each diagram to get a sense of how each data set represents chemical space, it would be better if we could directly compare the subtrees they represent. We can do just that using the exact same function, inputting both data sets into the function `display_subtree()` as the following example demonstrates. 

```{r subtree-plots-overlap, fig.cap="subtree-plots-overlap", fig.align='center', fig.dim=c(6,4)}
display_subtree(data_1 = biosolids_classified, 
                data_2 = usgswater_classified, 
                name_1 = 'Biosolids', 
                name_2 = 'USGS Water')
```

In \@ref(fig:subtree-plots-overlap), branches and labels are colored based on whether they are members of classifications of one, both, or neither data set. This gives an indication of how the chemical space represented by each data set overlaps through visualization of the induced subtrees within the full ChemOnt tree. From this visualization, it is also possible to determine the areas in chemical space unique to each data set.

While this particular visual can be informative, if the taxonomy is fairly large compared to the subtree induced by a data set, the diagram generated by `display_subtree()` can be cluttered and difficult to interpret. One solution for improving clarity is by pruning away extraneous branches and labels not represented by the subtree. We demonstrate this using the function `prune_and_display_subtree()` on both data sets.

```{r pruned-subtree,  fig.align='center', fig.dim=c(12,12), out.height=600, out.width=600}
prune_and_display_subtree(data = biosolids_classified)
prune_and_display_subtree(data = usgswater_classified)
```

In this visualization, the extraneous branches and tips not included in the set of classification labels of the data set are pruned and the remaining subtree is displayed. While there is still a lot of information displayed through the tip labels, this visualization provides a much closer look at the subtree induced by the data set than the previous visual that displayed the subtree within the whole taxonomy. Also observe that the shape of the subtree, while similar to the shape of the subtree displayed within the full ChemOnt tree, may change based on the set of extraneous branches and nodes that are pruned away.

We note a few things about this diagram and the `prune_and_display_subtree()` function. First, the output of the function is a `phylo` object consisting of the subtree and a diagram of the subtree (or just the `phylo` object if the function parameter `no_plot = TRUE` is used). Second, while many chemical classifications terminate with a tip label as the most specific label in the classification, there are some classifications that terminate with an internal node. If we were just to delete the internal nodes and tips not represented by classifications for a data set using `ape::drop.tip()`, the internal nodes that were terminal labels (and now are tips of the subtree) for classifications would appear in the diagram somewhere between the outer layer of tips and the root. The `prune_and_display_subtree()` function adjusts the branch lengths to accommodate the new structure of the subtree and extends these newly created tip labels of the subtree to match the pre-existing tip labels. This is recorded in the `edge.length` list of the output `phylo` object. A visual comparison between the branches in the subtree and the subtree within the entire taxonomy may show slight differences as a result of this branch adjustment. Third, with the omission of the extraneous branches and labels, there is the possibility that branches of the pruned subtree have rotate relative to their orientation within the ChemOnt tree. The structure of the subtree is the same, but the visual representation may differ.


In a manner similar to the output of `display_subtree()` when comparing two data sets, we may wish to look at the induced subtrees of two different data sets and compare membership of labels in one subtree witn the other subtree. To achieve this, we use the function `data_set_subtrees()` as we illustrate in the following example.

```{r pruned-subtree-overlap,  fig.align='center', fig.dim=c(12,12), out.height=600, out.width=600}
data_set_subtrees(data_1 = biosolids_classified, 
                  data_2 = usgswater_classified, 
                  name_1 = 'Biosolids', 
                  name_2 = 'USGS water')
```

The diagrams generated by the function `data_set_subtrees()` are useful for illustrating the portions of each data set-induced subtree that are also represented by labels from the classifications of the other data set. The output of the function consists of two tree diagrams, corresponding to the subtrees induced by each data set. Within each diagram, branches and nodes are highlighted different colors depending on whether the associated label is shared by both sets of classifications of the two data sets or is specific to the subtree in which its located. However, much like with the `display_subtree()` output tree visualization, the diagrams generated by `data_set_subtrees()` do not reflect the level to which the overlap occurs, nor do they relate a label in the overlap to the number of chemicals from each data set associated to that classification label. 

To quantify the level of overlap, we need to use a separate tree visualization diagram. We employ the function `leaf_fraction_subtree()` to create diagrams that convey this particular information.

```{r biosolids-leaf-fraction,  fig.align='center', fig.dim=c(12,8), out.height=400, out.width=600}
biosolids_leaf_fraction <- leaf_fraction_subtree(data_1 = biosolids_classified, 
                                                 data_2 = usgswater_classified, 
                                                 name_1 = 'Biosolids', 
                                                 name_2 = 'USGS water')
biosolids_leaf_fraction[[1]]
kableExtra::kbl(head(biosolids_leaf_fraction[[2]]))%>%
  kableExtra::kable_styling(bootstrap_options = 'striped', font_size = 9)
```

We also reverse the roles each data set plays to demonstrate the other overlap visualization.

```{r usgs-leaf-fraction,  fig.align='center', fig.dim=c(12,8), out.height=400, out.width=600}
usgswater_leaf_fraction <- leaf_fraction_subtree(data_1  = usgswater_classified, 
                                                 data_2 = biosolids_classified, 
                                                 name_1 = 'USGS water', 
                                                 name_2 = 'Biosolids')
usgswater_leaf_fraction[[1]]
kableExtra::kbl(usgswater_leaf_fraction[[2]][1:5, ])%>%
  kableExtra::kable_styling(bootstrap_options = 'striped', font_size = 9)
#  kbl() %>%
#  kable_styling(bootstrap_options = c("striped", "hover")) %>%
#  kable_classic()
```

The output of this function consists of a data frame and a tree visualization. The data frame lists each classification label that shows up as a terminal label in a classification for a chemical in the first data set. In addition, the data frame also displays the number of the chemicals that terminate with that label from the first data set, the number that are present in the second data set, and finally the percentage of shared chemicals within the first data set.


The tree visualization features the subtree induced by the first data set. The visualization displays the overlap data contained in the data frame by coloring the terminal label tips based on the degree of overlap. The legend shows the percentage of shared chemicals per terminal classification label using a color gradient that corresponds to the tip and layered colors.

We can also plot additional numeric data from a given data set in layers around the subtree induced by the data set. For instance, in the `biosolids_classified` data set, there is a column `AVERAGE_MASS` which gives the average molecular mass for each chemical in the data set. We can group these by their classification and examine boxplots of each set of grouped data. Moreover, we can also include taxonomic levels for which labels will be generated in concentric layers. 

```{r circ-tree-biosolids-mass-tip-color, fig.align='center', fig.dim=c(12,8), out.height=400, out.width=600}
circ_tree_boxplot(biosolids_classified, 
                  col = 'AVERAGE_MASS', 
                  title = 'Biosolids', 
                  tippoint_boxplot = TRUE, 
                  layers = c('kingdom', 'superclass'))
```

If we want to suppress the tippoint and boxplot colors, we can easily do so.

```{r circ-tree-biosolids-mass-no-tip-color, fig.align='center', fig.dim=c(12,8), out.height=400, out.width=600}
circ_tree_boxplot(biosolids_classified, 
                  col = 'AVERAGE_MASS', 
                  title = 'Biosolids', 
                  layers = c('kingdom', 'superclass'))
```

# Similarity between trees

The tree visualization functions we have demonstrated thus far have focused on a visual exploration of chemical space and how each data set spreads through it. We have seen how we can examine the overlap in chemical space between data sets and how to examine more closely the subtrees representing each data set. However, there are some more quantitative methods of exploring these overlaps that we have yet to cover.

## Similarity measures

The notion of similarity within ontologies and taxonomies has been an area of interest across a variety of disciplines. These aim to compare pairs of nodes in a tree with each other to gain insight on how these nodes relate to each other. Some methods involve examining just the pair of paths from the root of the tree to each of the nodes, while others may examine information more intrinsic to each node. While there is a lot to discuss and explore in the area of similarity measures, we will postpone that to the future and focus on how to use these similarity measures. We will highlight the main points of similarity measures relevant to the uses in this paper and then demonstrate visualizations that leverage them.

Jaccard similarity examines the path from the root to each node in a given pair of nodes, and relates these individual paths to the shared portion of the path (which may possibly be just the root). We can relate these in the following expression $$\text{sim}_{\text{Jac}}(v_1, v_2) = \frac{l(mrca(v_1, v_2))}{l(v_1) + l(v_2) - l(mrca(v_1, v_2))}$$ where $l(v_i)$ denotes the length of the root-to-node path for node $v_i$ and $mrca(v_i, v_j)$ denotes most recent common ancestor for nodes $v_i$ and $v_j$, the shared node in the root-to-node paths for nodes $v_i$ and $v_j$ furthest from the root (and in some cases possibly the root). This notion of similarity is calculated using the function `general_Jaccard_similarity()`, which takes as parameters a tree and two labels and returns the Jaccard similarity of the two labels within the tree. We exclude the case when the root is one of the nodes being compared. Note, if $v_i = v_j$, then $\text{sim}_{\text{Jac}}(v_i, v_j) = 1$.

Some trees may come with a probability distribution, associating to each node a probability such that the sum over all nodes of the probabilities is 1. In the case that a tree does not have such a distribution, we can still derive a node-specific value for each node in the tree. In one such method, we look at the number of descendants a node has and compare this with the total number of nodes in the tree. We would also like for each node to have a higher value than any of its ancestors, with the root having the minimum value over all nodes. One way to achieve this is by comparing the number of nodes in a given subtree with a specified node as the root of the subtree with the total number of nodes of the entire tree, evaluating a monotonically decreasing function on these values at each node, and examining their ratio. In particular, for node $v_i$, define $$\text{IC}(v_i) = 1 - \frac{\log(1 + |\text{V}_{v_i}|)}{\log(|V|)}$$ where $V_{v_i}$ denotes the descendants of node $v_i$ and $|V|$ is the total number of nodes in the tree. In the case that $v_i$ is a tip, it has no descendants so $\text{IC}(v_i) = 1 - \frac{\log(1)}{\log(|V|)} = 1$. If $v_i$ is the root, then $$\text{IC}(v_i) = 1 - \frac{\log(1 + |\text{V}_{v_i}|)}{\log(|V|)} = 1 - \frac{\log(|V|)}{\log(|V|)} = 0.$$ Also note that if $v_i$ is an ancestor of $v_j$, then $|\text{V}_{v_i}| > |\text{V}_{v_j}|$ and since the function $f(x) = 1 - \frac{\log(1 + x)}{N}$ (for $N > 0$) is monotonically decreasing for $x > 0$, it follows that $\text{IC}(v_i) < \text{IC}(v_j)$. Hence, the function above fits the desired properties. 

One way to frame the concept of information content is the idea that the less likely a node appears in a generic path starting from the root and ending at an arbitrary node, the more information it tells when we know the node is on a path given to us. So for instance, the only path a tip can exist on is the unique path connecting it with the root. However, for an ancestor of a tip, there are more paths that include this node, so knowing the ancestor is on a path gives less information about what the whole path might be. Since every path starting at the root includes the root, knowing the root is on the path yields no information.

To generate the information content for a tree, we can use the function `attach_information_content()` which takes in a tree as the only required parameter. This function then adds a data frame to the tree, with each row corresponding to a node of the tree and a column with the information content of each node. The data frame also includes the number of descendants, children, and the level for each node. Note that all of the tips in a tree have 0 descendants and an information content of 1, given by the `log_descendants` column. The root has an information content of 0. Any other nodes have the desired inequality in the values of their information content as it relates to the number of descendants.

Once an information content value is established for each node, we can then use similarity measures that rely on information content to compare nodes.

The first such method is called Resnik similarity. This is defined for two nodes $v_i$ and $v_j$ as $$\text{sim}_{\text{res}}(v_1, v_2) = \text{IC}(mrca(v_i, v_j)).$$ Observe that this is symmetric and when $v_i = v_j$ just returns the information content of the node itself. Note that for nodes that are not tips, their self-similarity is not always equal to 1. This implicitly encodes the fact that such a node tells less information than more specific nodes (nodes with fewer descendants). Also, since the information content of the root is zero, any pair of nodes containing the root will return a similarity value of zero.

There are additional similarity measures that build off of Resnik similarity. These will in fact return a value of 1 for self-similarity of nodes unlike in the case of Resnik similarity.

The next method is Lin similarity. This resembles Jaccard similarity in that it is the ratio of a value derived from the most recent common ancestor of a pair of nodes with values derived from the nodes themselves. In particular, we define $$\text{sim}_{\text{lin}}(v_i, v_j) = \frac{2 \times \text{sim}_{\text{res}}(v_i, v_j)}{\text{IC}(v_i) + \text{IC}(v_j)}.$$ Since the numerator is a scaled form of Resnik similarity, a pair of nodes with the root as their most recent common ancestor will have a value of zero for their Lin similarity. However, unlike Resnik similarity, if $v_i = v_j$, then $2 \times \text{sim}_{\text{res}}(v_i, v_i) = 2 \times \text{IC}(v_i)$, so the self-similarity value is equal to 1. Another thing to note is that for a pair of nodes with at least one not equal to the root, $$0 < \text{IC}(v_i) + \text{IC}(v_j) \leq 2$$ so $$1 \leq \frac{2}{\text{IC}(v_i) + \text{IC}(v_j)}$$ from which it follows that $$\text{sim}_{\text{res}}(v_i, v_j) \leq \text{sim}_{\text{Lin}}(v_i, v_j).$$ 

We define the self-similarity of the root to be 1 to reflect the fact that in Lin similarity, self-similarity is equal to 1. This keeps intact the relation above between Resnik similarity and Lin similarity.

An alternative take on normalizing the similarity value for a pair of nodes takes advantage of the inequality $$2 \times \text{sim}_{\text{res}}(v_i, v_j) \leq \text{IC}(v_i) + \text{IC}(v_j).$$ Taking the difference yields The following inequality $$0 \leq \text{IC}(v_i) + \text{IC}(v_j) - 2 \times \text{sim}_{\text{res}}(v_i, v_j) \leq 2.$$ Dividing this inequality by 2 restricts the values the middle expression can take to the interval $[0,1]$. However, we want the similarity to be equal to 1 if $v_i = v_j$ and the expression above returns a value of 0 instead. The solution is to take the difference of 1 and this expression, yielding $$\text{sim}_{\text{JiangConrath}}(v_i, v_j) = 1 - \frac{\text{IC}(v_i) + \text{IC}(v_j) - 2 \times \text{sim}_{\text{res}}(v_i, v_j)}{2}.$$ This was developed by Jiang and Conrath and is thus named. 

Things to note are that when the most recent common ancestor for a pair of nodes $v_i$ and $v_j$ is the root, this similarity measure does not necessarily return a value of zero. In fact, rewriting the expression for Jiang and Conrath similarity, we see that it is equal to $$\text{sim}_{\text{JiangConrath}}(v_i, v_j) = \text{sim}_{\text{res}}(v_i, v_j) + \frac{2 - (\text{IC}(v_i) + \text{IC}(v_j))}{2} \geq \text{sim}_{\text{res}}(v_i, v_j)$$ since $$\text{IC}(v_i) + \text{IC}(v_j) \leq 2.$$ One thing this reflects is that if a pair of such nodes represents a large portion of the tree based on their descendants, they are more likely to be closer to the root and thus more related to each other. 

We also observe that $$\text{sim}_{\text{JiangConrath}}(v_i, v_j) \geq \text{sim}_{\text{Lin}}(v_i, v_j).$$ This follows from the following argument. If $v_i = v_j$ are the root, $$\text{sim}_{\text{Lin}}(v_i, v_j) = \text{sim}_{\text{JiangConrath}}(v_i, v_j) = 1.$$ Otherwise, if $$\text{sim}_{\text{res}}(v_i, v_j) = 0,$$ $$\text{sim}_{\text{Lin}}(v_i, v_j) = 0 \leq \text{sim}_{\text{Lin}}(v_i, v_j).$$ If $$0 < \text{sim}_{\text{res}}(v_i, v_j) = \text{sim}_{\text{Lin}}(v_i, v_j),$$ then $$\text{IC}(v_i) + \text{IC}(v_j) = 2,$$ $$\text{sim}_{\text{JiangConrath}}(v_i, v_j) = \text{sim}_{\text{res}}(v_i, v_j) = \text{sim}_{\text{Lin}}(v_i, v_j).$$ If $$0 < \text{sim}_{\text{res}}(v_i, v_j) < \text{sim}_{\text{Lin}}(v_i, v_j),$$ since $$1 \geq \text{sim}_{\text{Lin}}(v_i, v_j),$$ it follows that $$\frac{1}{\text{sim}_{\text{Lin}}(v_i, v_j)} > 1$$ and $$\frac{\text{sim}_{\text{Lin}}(v_i, v_j) - \text{sim}_{\text{res}}(v_i, v_j)}{\text{sim}_{\text{Lin}}(v_i, v_j)} > \text{sim}_{\text{Lin}}(v_i, v_j) - \text{sim}_{\text{res}}(v_i, v_j)$$ from which it follows that $$\text{sim}_{\text{JiangConrath}}(v_i, v_j) = \text{sim}_{\text{res}}(v_i, v_j) + 1 - \frac{\text{sim}_{\text{res}}(v_i, v_j)}{\text{sim}_{\text{Lin}}(v_i, v_j)} > \text{sim}_{\text{Lin}}(v_i, v_j).$$ Hence, in all cases $$\text{sim}_{\text{JiangConrath}}(v_i, v_j) \geq \text{sim}_{\text{Lin}}(v_i, v_j).$$

When comparing a pair of nodes that are tips, say $v_i$ and $v_j$, then observe that since $$\text{IC}(v_i) = \text{IC}(v_j) = 1,$$ $$\text{sim}_{\text{res}}(v_i, v_j) = \text{sim}_{\text{lin}}(v_i, v_j) = \text{sim}_{\text{JiangConrath}}(v_i, v_j).$$ Thus, the three similarity measures all agree on pairs of tips but diverge otherwise.

Now, the function `attach_information_content()` generates information content for an input tree, and the functions `general_Jaccard_similarity()`, `general_Resnik_similarity()`, `general_Lin_similarity()`, `general_JiangConrath_similarity()` all can be used to compare a pair of nodes on a given tree. Moreover, if one wants to compute the similarity for all pairs, the function `generate_similarity_matrix()` will do so for a given tree and similarity measure function. The computation is lengthy for the ChemOnt tree and so these matrices have been previously computed and stored. They are accessible as `chemont_jaccard`, `chemont_resnik_IC_SVH`, `chemont_lin_IC_SVH`, and `chemont_jiangconrath_IC_SVH`.

## Visualizing similarity

Now, we move to using these in visualizations.

The function `generate_heatmap()` will take in a pair of data sets and compare the induced subtrees using similarity measures. In the example below, we use the Jaccard similarity values of the ChemOnt tree, with rows representing classifications from `usgswater_classified` and columns representing classifications from `biosolids_classified`. In this diagram, we have specified for there to be 9 row and 9 column clusters within the hierarchical clustering of the heatmap.

```{r heatmap-biosolids-usgs, fig.align='center', fig.dim=c(6,4)}
biosolids_usgs_ht <- generate_heatmap(tree_object = chemont_tree, 
                                      matrix = chemont_jaccard, 
                                      row_data = usgswater_classified, 
                                      column_data = biosolids_classified, 
                                      row_split = 9L, column_split = 9L, 
                                      row_title = 'USGS Water', 
                                      column_title = 'Biosolids', 
                                      name = 'Jaccard Similarity')
biosolids_usgs_ht
```

In the diagram created by the `generate_heatmap()` function, there are several features that are included. The dendrogram out of which the row and column clusters are determined are displayed on the left side and the top, respectively. Between these dendrograms and the clusters is a layer showing the logarithm of the number of times a row or column label occurs within the set of classifications for each data set. To the right of the diagram is a color gradient indicating the similarity values displayed within the heatmap. Observe that in row cluster 2 and column cluster 2, there appears to be a lot of high similarity values. Also note that in row cluster nine, column cluster 8, there are both high similarity values and low similarity values. We analyze these clusters by visualizing the labels associated to each data set in these clusters using tree diagrams.

```{r rc-cluster-2-2, fig.align='center', fig.dim=c(18,12), out.height=480, out.width=720}
generate_tree_cluster(tree = chemont_tree, tree_object = chemont_tree, 
                      htmap = biosolids_usgs_ht, row_cluster = 2, 
                      column_cluster = 2, row_name = 'USGS Water', 
                      column_name = 'Biosolids', isolate_subtree = TRUE)
```

Observe that only the superclass 'Benzenoids' is represented. In the second diagram, we prune away all extraneous superclass branches. Notice that the labels present in the data sets are indicated by points, colored by whether they are found in one or both data sets.




```{r rc-cluster-9-8, fig.align='center', fig.dim=c(18,10), out.height=350, out.width=630}
generate_tree_cluster(tree = chemont_tree, tree_object = chemont_tree, 
                      htmap = biosolids_usgs_ht, row_cluster = 9, 
                      column_cluster = 8, row_name = 'USGS Water', 
                      column_name = 'Biosolids', isolate_subtree = TRUE)

```

In this pair of diagrams, we observe that there are several superclasses represented. In fact, there are labels from the USGS Water data set present in all superclasses highlighted, though the labels from the biosolids data set are only found within the "Organic nitrogen compounds" superclass. In the second diagram, we can observe this more closely. 


