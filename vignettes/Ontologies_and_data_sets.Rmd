---
title: "Ontologies_and_data_sets"
author:
  - name: "Paul Kruse"
    affiliation: "United States Environmental Protection Agency"
    email: "kruse.paul@epa.gov"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Ontologies_and_data_sets}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
devtools::load_all()
#library(treecompareR)
```

# Introduction

In this vignette we introduce how to build an ontology with a taxonomic structure in R and how to classify entries from a data set using this ontology. The case study we will explore is the ChemOnt ontology, the underlying structure of the chemical classification tool [ClassyFire](http://classyfire.wishartlab.com/). 

# Building the taxonomy from an ontology

An ontology is a useful tool that provides a organizational framework to relate particular ideas. The Linnean system is an early example of an ontology, with the goal of organizing living creatures into a sensible framework. More recently, the [Gene Ontology](http://geneontology.org/) has undergone major development with the goal of creating a computational model of biological systems from molecular to organism level.

The ontology we will study in this vignette is the ChemOnt ontology of ClassyFire. This has a taxonomy structure, that of a rooted tree, where for any pair of labels either one is a child (or descendant) of the other or they share a common ancestor. The labels of the ontology, with their identification number and their parent identification name can be found at [ChemOnt tax nodes](http://classyfire.wishartlab.com/tax_nodes.json). We download this and read it (as of writing this, May 10, 2022).

```{r}
library(jsonlite)
tax_nodes <- jsonlite::read_json('http://classyfire.wishartlab.com/tax_nodes.json')
length(tax_nodes)
tax_nodes[[1]]
str(tax_nodes[[1]])
```

Observe that there are 4825 entries in `tax_nodes` and each entry is a list of length three, with entries `name`, `chemont_id`, and `parent_chemont_id`. We need to collect this information and organize it. To do so, we now build a data.frame from this list. The column names will be `Name`, `ID`, and `Parent_ID`. We first set the `parent_chemont_id` value of the first entry in `tax_nodes` to `NA` so that we can read in the list correctly.

```{r}
tax_nodes[[1]]$parent_chemont_id <- NA
chemont_taxnodes <- data.frame('Name' = sapply(tax_nodes, function(t) {t[[1]]}),
                               'ID' = sapply(tax_nodes, function(t) {t[[2]]}),
                               'Parent_ID' = sapply(tax_nodes, function(t) {t[[3]]}))
head(chemont_taxnodes)
```

Now, we can read in this data.frame using `generate_tree()` to build the taxonomy.

```{r}
chemont_taxonomy <- generate_tree(dataframe = chemont_taxnodes)
str(chemont_taxonomy)
```

What `generate_tree()` returns is a list of two objects, a phylo object and a dataframe used in creating the phylo object. With the phylo object, we can apply tree methods and visualizations to explore and display its structure.

Alternatively, we can run `generate_tree()` on a JSON file. The column names from the dataframe `chemont_taxnodes` - `Name`, `ID`, `Parent_ID` - need to be the names for each entry in the JSON file. We convert the dataframe `chemont_taxnodes` to JSON format and read it in using `generate_tree()`. Then we verify that indeed the output matches the output from using the dataframe.

```{r}
chemont_taxnodes_JSON <- jsonlite::toJSON(chemont_taxnodes)

chemont_taxonomy_2 <- generate_tree(chemont_taxnodes_JSON)

identical(chemont_taxonomy, chemont_taxonomy_2)
```

We now isolate the tree structure and produce a simple visualization.

```{r, fig.align='center', fig.dim=c(6,4)}
chemont_tree <- chemont_taxonomy[[1]]
ggtree(chemont_tree) + layout_circular()
```

This is a very dense diagram, as there are 4825 nodes including the root which is centered. We now turn our attention to classifying data sets of chemical entries and using those classifications to produce visualizations within the above tree.

# Classifying data

The ClassyFire tool takes in chemical identifiers, such as a SMILES string or an InChIKey, and returns a classification of that chemical. Currently, one can manually enter a list of SMILES of InChIKeys using the web application of [ClassyFire](http://classyfire.wishartlab.com/queries/new). However, for a more programmatic approach, there is an API available for more automated use. The package [classyfireR](https://cran.r-project.org/web/packages/classyfireR/index.html) was designed for use with the API and we use this with some functions from treecompareR to quickly classify data sets.

## Classifying by InChIKey

The function `classify_datatable()` takes in a data.table of chemicals that will be classified using ClassyFire. The data.table must contain columns with the names `PREFERRED_NAME`, `CASRN`, `INCHIKEY`. Additional columns are permitted, provided they do not match with any of the taxonomic level names of ClassyFire - `kingdom`, `superclass`, `class`, `subclass`, `level5`, `level6`, `level7`, `level8`, `level9`, `level10`, `level11`. 

In the event that `CASRN` and `InChIKey` data for each chemical is missing we can retrieve this data, when available, using a batch search from the [CompTox Dashboard](https://comptox.epa.gov/dashboard/batch-search). However, for a more programmatic approach, we use the API of the [Hazard Comparison Dashboard](https://hazard.sciencedataexperts.com/#/). 

Using the Hazard Comparison Dashboard API approach, we feed in a list of `DTXSID`, `CAS`, `SMILES`, `NAME` information and are returned in a`HazardComparisonDashboard` object, which consists of a list with entries for `dtxsid`, `casrn`, `name`, `smiles`, `inchikey`. From this, we can then construct the data.table for use with `classify_datatable()`. In the event that a chemical remains unclassified, we can feed the classified data.table from `classify_datatable()` into the function `classify_by_smiles` which will try to classify the unclassified chemicals using their SMILES strings. Once completed, a data.table is return, with all chemicals having been classified either through their InChIKey or SMILES, or unclassified.

In the `data` folder, we read in a csv file `Chemical List BIOSOLIDS-2022-05-10.csv` which contains a set of 726 chemicals from the CompTox dashboard and store this as a data.table. This data comes from [biosolids](https://comptox.epa.gov/dashboard/chemical-lists/BIOSOLIDS) and was downloaded as a csv file on May 10, 2022.

```{r}
library(data.table)
biosolids <- data.table(chemical_list_biosolids_2022_05_10)
biosolids[1:2]
names(biosolids)
```
We feed this data.table to `classify_datatable()`, and then feed the output data.table from `classify_datatable()` to `classify_by_smiles()`.

```{r, message=FALSE, results='hide'}
#setnames(biosolids, old = c('PREFERRED.NAME'), new = c('PREFERRED_NAME'))
biosolids_classified <- classify_datatable(biosolids)
biosolids_classified <- classify_by_smiles(biosolids_classified)
```

We then take a look at the classified chemicals and isolate which chemicals did not receive any classification.

```{r}
head(biosolids_classified)
biosolids_classified[kingdom == '',]
```

Notice that in the case of the chemicals that did receive a classification, there are taxonomic labels from ChemOnt in the last 11 columns, some with more labels than others. These labels give the ClassyFire classification for each chemical.

We now demonstrate how to gather the necessary information using `get_chemical_identifiers()` if there is missing data corresponding to the columns `PREFERRED_NAME`, `CASRN`, `INCHIKEY`. In the following example, we collect just the CASRNs from the biosolids list and use these as the starting point. We then apply the `get_chemical_identifiers()` function to this list to get the relevant chemical information. Then we run ClassyFire on this.

```{r, message=FALSE, results='hide'}
biosolids_casrn <- biosolids[, CASRN]

biosolids_2 <- batch_chemical_identifiers(biosolids_casrn)
biosolids_2_classified <- classify_datatable(biosolids_2)
biosolids_2_classified <- classify_by_smiles(biosolids_2_classified)
```

Observe that there is considerable agreement with the classified chemicals using both approaches.

```{r}
biosolids_classified[kingdom != '', .N]
biosolids_2_classified[kingdom != '', .N]
length(intersect(biosolids_classified[kingdom != '', unique(CASRN)], biosolids_2_classified[kingdom != '', unique(CASRN)]))

setdiff(biosolids_classified[kingdom != '', unique(CASRN)], biosolids_2_classified[kingdom != '', unique(CASRN)])
setdiff(biosolids_2_classified[kingdom != '', unique(CASRN)], biosolids_classified[kingdom != '', unique(CASRN)])
```
We can observe that using the information provided from the CompTox dashboard directly, 691 of 726 chemicals were classified. Using just the CASRN values as inputs, collecting relevant data from the Hazard Comparison Dashboard API, and running ClassyFire on this data resulted in the classification of 686 of 726 chemicals. Note that there were 682 chemicals in common that were classified with 9 in the first method not in the second, 4 in the second method not in the first. This means that if we were to combine both sets of classified data, there would be 695 of 725 chemicals with classifications. Potential sources of discrepancies in these numbers included different availability of data contained in the CompTox Dashboard and the Hazard Comparison Dashboard. The underlying conclusion though is that these two methods yield two different pathways for attaining chemical classification programmatically and are similar in their level of success.

Once we have classifications available for the chemicals in a data set, there a variety of avenues we can use to explore the 
chemical space represented by the data.

For instance, we can show the subtree of the ChemOnt tree representing the classifications of the data set. We often refer to this subtree as induced by the data set.

```{r, fig.align='center', fig.dim=c(6,4)}
display_subtree(data_1 = biosolids_classified, name_1 = 'Biosolids')
```

Notice that the full ChemOnt tree is displayed, with branches and tip labels colored depending on whterh they are included among the labels represented by the data set.

If we want to look at just the subtree and prune away any label not included in the subtree, we can do so. The following function returns both the `phylo` object representing the tree and the tree diagram, though we can choose to include only the phylo object. We can also choose to include the tips. We demonstrate the diagram with and without the tips. Suppressing the tips can be really useful when there are a lot of branches as the diagram can get cluttered otherwise.

```{r, fig.align='center', fig.dim=c(6,4)}
prune_and_display_subtree(biosolids_classified)
prune_and_display_subtree(biosolids_classified, show_tips = FALSE)
```

If there is numeric data attached to the chemical data, such as `AVERAGE.MASS` in `biosolids_classifed`, we can plot this in boxplots that accompany the tree diagram as the following example demonstrates. This requires supplying a data.table that has a `terminal_label` column for grouping together classifications.

```{r, fig.align='center', fig.dim=c(6,4)}
biosolids_classified_terminal <- add_terminal_label(biosolids_classified)
circ_tree_boxplot(biosolids_classified_terminal, col = 'AVERAGE_MASS')
```

We may also be interested in looking at the number of unique labels for each taxonomic level for a data set or several data sets. In the following exmaple, we look at just the biosolids data set.

```{r, fig.align='center', fig.dim=c(6,4)}
label_bars(biosolids_classified_terminal)
```

Note that in the second diagram, the facets corresponding to levels 9, 10, and 11 are empty. This is due to the fact that there are no classifications of chemicals that have labels down to level9 (and thus subsequent levels).
