---
title: "JStatSoft"
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{JStatSoft}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
#library(treecompareR)
devtools::load_all()
#library(kableExtra)
```

# Abstract

This paper presents the **treecompareR** package for `R`, which provides tools for reproducible visualizations of data through the use of taxonomies. The package builds on developments from **gplot2**, **ggtree** to provide visualizations tailored for use with taxonomic classification data. It also provides a pipeline for gathering chemical classification data using **classyfireR** and the [Hazard Comparison Dashboard](https://hazard.sciencedataexperts.com/#/). Additionally, it provides tools that leverage developments in network analysis to compare data sets. While designed specifically for chemical classification objectives using [ClassyFire](http://classyfire.wishartlab.com/), **treecompareR** provides tools for use with more general taxonomies.


# Introduction

Classification of objects has been a source of much development of structures across various fields of science. Organizing objects into a coherent structure helps one to understand how these objects relate to each other and can lead to the discovery of connections between various sets of objects. How one organizes the objects may depend on underlying attributes that the objects possess. 

Ontologies provide a framework for comparing objects through a variety of different relation types. Restricting the attention to taxonomies, one can focus specifically on the "is a" relation, e.g. "a dog (*canis familiaris*) is a canid", "a canid is a mammal," "a mammal is an animal", and study how objects relate to one another under this scheme. One well known example of this organizational structure in use is the Linnaean system for classifying life, sometimes referred to as the "tree of life". As a taxonomy, the organizational structure is given by a tree, which consequently lends itself to analysis using graph theory techniques. [CLR: Hug et al. 2016] [other citation?]

[CLR:Add refs to Gene Ontology project?]

Cheminformaticians commonly encounter the question of defining chemical similarity. Particularly when training models (e.g. QSARs), there is a need to define the chemical domain of applicability of the model. Given that the model was trained on a fixed set of chemicals, in order to judge confidence in model predictions for a new chemical, researchers need to quantify how similar the new chemical is to the training set.

Analyses of chemical similarity have tended to focus on molecular fingerprints and structural features. These results tend to be high-dimensional and difficult to visualize. As well, they can be difficult to interpret for non-chemists.

Chemical structural features map to chemical categories, of course. Chemists can look at a diagram of molecular structure and identify whether a chemical is, for example, a dioxin or an amino acid. However, this mapping has not been explicitly defined, until recently.

We present the package **treecompareR** as a solution to the specific needs of creating a pipeline to classify chemicals in a data set, visualize the chemical space they represent, and compare the data sets from the point of view of chemical space. The ChemOnt taxonomy is analogous to the Linnean "tree of life" or other phylogenetic trees. Therefore, to visualize chemical space using the ChemOnt taxonomy, owe build upon the excellent package [ggtree](https://bioconductor.org/packages/release/bioc/html/ggtree.html), which was originally developed for visualization of phylogenetic tree data. We extend ggtree with functions that simplify the task of creating certain complex visualizations that are frequently of use when visualizing similiarities and differences in chemical lists using the ChemOnt taxonomy.



# ClassyFire and ChemOnt
In 2016, the [ClassyFire](http://classyfire.wishartlab.com/) tool was introduced, in the work of [Djoumbou et al](https://jcheminf.biomedcentral.com/articles/10.1186/s13321-016-0174-y). This work consists of a defined chemical ontology, ChemOnt, consisting of 4825 classification labels (nodes). The ontology is a strictly hierarchical taxononomy, where each node has exactly one parent. The ClassyFire web tool takes in chemical identifiers such as InChIKey or SMILES strings and, based on molecular structure, provides a classification of the chemical within the taxonomy.

The full classification of a chemical structure includes several levels of specificity: kingdom (level 1), superclass (level 2), class (level 3), subclass (level 4), and potentially more specific levels from level 5 to level 11. Not all chemical classifications include all levels of specificity.

The ClassyFire ontology can be downloaded in JSON format at [http://classyfire.wishartlab.com/tax_nodes.json](http://classyfire.wishartlab.com/tax_nodes.json)  or in OBO format at [http://classyfire.wishartlab.com/downloads](http://classyfire.wishartlab.com/downloads). Both file formats contain the same information: node labels, node ID numbers, and node parent ID numbers, for each of the 4825 nodes in the taxonomy.

To construct a tree object representing the taxonomy, we first convert the taxonomy to a `data.frame` object with columns `Name`, `ID`, and `Parent_ID`.  This \code{data.frame} may be read from an OBO file using e.g. `ontologyIndex::get_ontology()` and `ontologyIndex::as.data.frame.ontology_index()`, or from a JSON
file using for example `jsonlite::fromJSON()`. This `data.frame` for the ChemOnt taxonomy is provided with the package, in data object `chemont_df`.

```{r}
head(chemont_df)
```


With this data in hand, we construct the tree object as follows.

```{r chemont-tree, fig.cap="chemont-tree"}
chemont_tree <- generate_taxonomy_tree(tax_nodes = chemont_df)
```

The output of this function is a`phylo` class object (see package `ape`), which itself is a list. Its elements describe the edges of the tree (connections between nodes), the number of internal nodes, the tip labels and internal node labels, and a set of edge lengths generated in the construction of the tree. One thing to note is that the edge lengths are artificial and are only used to speed up the creation of the tree, but do not represent any actual data corresponding to the tree. However, we retain the edge lengths as they are useful in creating visualizations.

```{r}
str(chemont_tree)
```

This `generate_taxonomy_tree()` function is not limited to the ChemOnt taxonomy. It can produce a tree representation of *any* hierarchical taxonomy, as long as that taxonomy can be represented in the form of a data frame with column names `Name`, `ID`, and `Parent_ID` and one row for each node in the tree. However, it cannot currently handle ontologies which are not strictly  hierarchical (e.g. Gene Ontology).

A `data.frame` representation of the `phylo` tree can be recovered using function `get_tree_df()`. Instead of ChemOnt IDs, this `data.frame` identifies nodes using their node numbers in the `phylo` tree. (That's useful information when you need to call functions that work on `phylo` trees but require you to specify node numbers, such as many functions in packages `ape` and `phangorn`.) This `data.frame` also includes a variable `level`, which specifies the level in the tree taxonomy for each node. Here, the root node is defined as level 0. In the ChemOnt taxonomy, "kingdom" is level 1, "superclass" is level 2, "class" is level 3, "subclass" is level 4. Levels 5 and above are "level5", "level6", etc. up to "level11". 

```{r}
head(get_tree_df(chemont_tree))
```


## Visualizing trees

Once a taxonomy tree is generated, it can be visualized using the function `display_subtree()`:

```{r}
display_subtree(base_tree = chemont_tree,
                base_name = "ChemOnt taxonomy") +
  hexpand(1)
```

By default, this visualization will label branches of the tree ("clades"). These are the arcs and labels around the outer edge of the tree.

The level at which clades are labeled is controlled using the `clade_level` argument. The default value of `clade_level` is "auto", which will choose one level below the level of the most recent common ancestor (MRCA) of all tips of the tree, or level 2, whichever is greater. For example, the MRCA of the tips of the full ChemOnt tree is level 0, the root node, "Chemical entities." One level below that is level 1, kingdoms ("Organic compounds" and "Inorganic compounds"). However, because level 1 is not very interesting, `clade_level = "auto"` will default to level 2.

If we wanted to label the kingdoms (level 1), that can be done by specifying `clade_level = 1`.

```{r}
display_subtree(base_tree = chemont_tree,
                base_name = "ChemOnt taxonomy",
                clade_level = 1)
```

To suppress clade labeling altogether, set `clade_level = NULL`.

```{r}
display_subtree(base_tree = chemont_tree,
                base_name = "ChemOnt taxonomy",
                clade_level = NULL)
```


As you can see, the full ChemOnt tree is extremely dense. To "zoom in" to a specific part of the tree, we can use the function `prune_and_display_subtree()` In the argument `prune_to`, provide the name of one or more nodes at any level desired. The function will prune the tree to keep only the specified node(s) and all of their descendants. For example, we can "zoom in" on the "Organohalogen compounds" superclass.

```{r}
prune_and_display_subtree(base_tree = chemont_tree,
                          prune_to = "Organohalogen compounds")
```
(Note that the default level for clade labeling is now level 3 (class), because the MRCA of the tips of the pruned organohalogen compounds tree is by construction "Organohalogen compounds", level 2.)
 
To access the pruned phylo-class tree object itself, use the function `prune_tree`. 

```{r}
oh_tree <- prune_tree(tree = chemont_tree,
           prune_to = "Organohalogen compounds")
str(oh_tree)
```

This pruned tree can be treated in exactly the same way as the original taxonomy tree. Any function that takes a phylo-class tree argument will work on the pruned tree.

To choose clades for pruning, you may want to list the clades of a tree at a specified level. Use the function `get_all_clades()`. For example, the following code lists the clades of the ChemOnt tree at the superclass level (level 2).

```{r}
get_all_clades(tree = chemont_tree, level = 2)
```

Features of this visualization can be easily controlled using various arguments to `display_subtree()`. 



## Controlling tree layout

By default, `display_subtree()` uses a circular tree layout. However, you can specify any layout known by `ggtree` (see [https://yulab-smu.top/treedata-book/chapter4.html#tree-layouts](https://yulab-smu.top/treedata-book/chapter4.html#tree-layouts) for a full list and examples). (In this example, we use the `ggtree::hexpand()` function to add horizontal space for the labels.)

```{r}
display_subtree(base_tree = oh_tree,
                base_name = "Organohalogen compounds",
                layout = "roundrect") +
  ggtree::hexpand(0.1)
```
## Controlling tree color, size, and linetype

For example, the color, size, and/or linetype of the tree can be controlled using the argument `base_opts`. The default value of this arugment is

```{r, eval = FALSE}
base_opts = list(color = "gray50",
                 size = 0.5,
                 linetype = 1)
```

meaning that the tree will be plotted in a medium gray color (`color = "gray50"`), with line width 0.5 (`size = 0.5`), and solid lines (`linetype = 1`). If instead we wanted to plot the tree in red, for example, we could do so:

```{r}
display_subtree(base_tree = oh_tree,
                base_name = "Organohalogen compounds",
                base_opts = list(color = "red")) +
  hexpand(1)
```


Any other parameters for the base tree (i.e., any parameters that would be optional arguments to `ggtree`) can also be added to `base_opts` as named list elements. For example, to use a fan layout with a specified angle, use `layout = fan` and add `open.angle` to `base_opts`:

```{r}
display_subtree(base_tree = oh_tree,
                base_name = "Organohalogen compounds",
                layout = "fan",
                base_opts = list(open.angle = 100))
```

The output of `display_subtree()` is a `ggtree` and `ggplot`-class object, so it can be manipulated using the grammar of `ggtree` and `ggplot2`. We have already seen an example of this when we used `ggtree:hexpand()` to expand the plot margins to make room for labels. For another example, we can use `ggplot2::theme()` to control the appearance of elements such as the plot title -- e.g., setting the title in a serif font, italicizing it, and right-justifying it.

```{r}
display_subtree(base_tree = oh_tree,
                base_name = "Organohalogen compounds") +
  ggplot2::theme(plot.title = ggplot2::element_text(family = "serif",
                                  face = "italic",
                                  hjust = 1)
                 )
```


# Example Research Problem: Chemical Contaminants in Water and Wastewater

Tree visualizations can be used to explore how different chemical lists are distributed across chemical space as defined by the ChemOnt taxonomy. This can be useful to inform chemical safety research.

Consider the question of chemical contaminants in water and wastewater. Under the Clean water Act, the United States Environmental Protection Agency works to identify chemical contaminants of potential concern to human health and the environment that may occur in both drinking water and in treated wastewater.  In wastewater, a medium of particular interest is *biosolids*, the semisolid, nutrient-rich product obtained by separating wastewater solids from liquids and treating the solids separately. Biosolids may be appplied to land as fertilizer or soil amendment, or may be disposed of in landfills or incinerated. Chemical contaminants in biosolids may make their way to humans, plants, or animals. Therefore, it's of interest to identify chemicals that may be found in biosolids.

One possible starting point is to consider chemical contaminants that have been found in surface water and/or ground water. Surface and ground water sources may be treated and used for drinking water, which ultimately means that this water goes down the drain and becomes part of the wastewater stream. Chemicals found in surface and ground water may therefore make their way into biosolids. Of course, they also may *not* make their way into biosolids. They may be removed during initial treatment of source water; they may be removed during the wastewater treatment process; or when liquids and solids are separated during wastewater treatment, they may preferentially remain in the liquids.

Both biosolids and ground/surface water have been tested for relatively long lists of chemical contaminants of interest. Of course, these lists don't necessarily include every chemical that might be in those media; there may be chemicals we don't even know to look for. However, as a starting point, it might be informative to compare lists of chemicals found in water and chemicals found in biosolids. Are certain classes of chemicals found in one medium but not the other, or in both media? How similar are the two lists of chemicals, and where are the overlaps and differences?

With the ClassyFire/ChemOnt ontology and the **treecompareR** package, we can start to explore these questions through visualization. We can visualize a tree for surface/groundwater chemicals, and a tree for biosolids chemicals. We can visualize where these trees overlap and where they do not. Furthermore, we can calculate quantitative similarity measures between the two trees, and visualize where similarity is higher and lower between branches of each tree.

## Chemical Lists

We use existing curated lists of chemical contaminants found in biosolisd and in surface/groundwater, publicly available (with many other curated chemical lists of interest) from the US EPA's CompTox Chemicals Dashboard. A curated list of 726 chemicals found in biosolids is available as the `BIOSOLIDS2021` dataset [cite Richardson & Williams 2021 https://www.nature.com/articles/s41597-022-01267-9] at [https://comptox.epa.gov/dashboard/chemical-lists/BIOSOLIDS2021](https://comptox.epa.gov/dashboard/chemical-lists/BIOSOLIDS2021). A curated list of 707 chemicals monitored in surface and groundwater by the United States Geological Service (USGS) is available as the `USGSWATER` dataset at [https://comptox.epa.gov/dashboard/chemical-lists/USGSWATER](https://comptox.epa.gov/dashboard/chemical-lists/USGSWATER).

Each list of chemicals includes chemical identifiers (prefererd name, CASRN, and DSSTox Substance ID) as well as structural identifiers (InChiKey and SMILES strings).

Here are the first few rows of each chemical list.

```{r}
head(BIOSOLIDS2021)
```


## ClassyFire classification of chemical lists

To compare these two chemical lists based on the ChemOnt taxonomy, first, the chemicals on each list must be classified according to ClassyFire. This can be accomplished using the publicly available [ClassyFire](http://classyfire.wishartlab.com/) web tool. This web tool takes a user-supplied InChiKey and returns the corresponding ClassyFire classification, if available. 

An interface to the API for the ClassyFire web tool is available through the **classyfireR** package. To simplify the process of querying the API for a list of InChiKeys, we have written two wrapper functions, `classify_inchikeys()` and `classify_structures()`. These functions take a user-supplied vectors of InChiKeys or SMILES strings (respectively) and return a `data.frame` with the corresponding classification for each input structure. 

If a classification was not available, the columns of the data.frame simply contain `NA_character_` values.

```{r, eval = FALSE}
BIOSOLIDS2021_class <- classify_inchikeys(BIOSOLIDS2021$INCHIKEY)
USGSWATER_class <- classify_inchikeys(USGSWATER$INCHIKEY)
```

Another wrapper function to the ClassyFireR API allows the user to query by SMILES string (or alternately InChiKey). The ClassyFire API will first query its existing lookup table. But if the provided structure is not in the lookup table, it may run the ClassyFire structure-based classification model on the "unknown" provided structure. 


```{r, eval = FALSE}
BIOSOLIDS2021_class <- classify_structures(BIOSOLIDS2021$SMILES)
USGSWATER_class <- classify_structures(USGSWATER$INCHIKEY)
```

The BIOSOLIDS2021 and USGSWATER data sets with ClassyFire classifications are stored in `BIOSOLIDS2021_class` and `USGSWATER_class`.

Now, let us examine these two data sets. Notice that there are 11 columns of ChemOnt data, starting with `kingdom`, `superclass`, and continuing through to `level11`, denoting the taxonomic levels of the ChemOnt ontology. For a given row, not all of these columns will be filled with labels, and the last non-empty column denotes the most specific classification label associated with the chemical represented by the row. While there are many columns in this table, we will only display a subset of these, namely `PREFERRED_NAME`, `INCHIKEY`,  `kingdom`, `superclass`, `class`, `subclass`, `level5`, to illustrate some of the important features in the data set.

```{r biosolids_classifications}
kableExtra::kbl(head(BIOSOLIDS2021_class[!is.na(BIOSOLIDS2021_class$kingdom),
                                         c('PREFERRED.NAME', 'INCHIKEY',
                            'kingdom', 'superclass', 'class', 'subclass', 
                            'level5')], 5),
                row.names = FALSE) %>%
 kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
 kableExtra::kable_classic() %>%
  kableExtra::landscape()
```

Note that in the second row, Diazepam has NA in the `level 5` column. This means that the most-specific classification for Diazepam is at the subclass level.
\
```{r usgs_classifications}

kableExtra::kbl(head(USGSWATER_class[!is.na(USGSWATER_class$kingdom),
                                     c('PREFERRED.NAME', 'INCHIKEY',
                            'kingdom', 'superclass', 'class', 'subclass', 
                            'level5')], 5),
                row.names = FALSE)  %>%
 kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
 kableExtra::kable_classic() %>%
  kableExtra::landscape()
```
Note that in row 5, Acenaphthenequinone has `NA` in both the `subclass` and `level 5` columns. This means that the most specific classification for Acenaphthenequinone is at the `class` level; it is not classified any more specifically than "Naphthalenes".

# Visualizing subtres

We can visualize which parts of the ChemOnt tree, or any subtree, are represented by chemicals in each data set. To do this, we use the function `display_subtree()`, which takes in a `data.frame` consisting of a classified list of chemicals, and returns a tree diagram with branches color-coded according to their membership in the chemical list. For purposes of illustration, here we use the pruned subtree for the "Organohalogen compounds" clade as our "base tree."

```{r subtree-plots, fig.cap="subtree-plots",  fig.align='center', fig.dim=c(6,4)}
display_subtree(base_tree = oh_tree,
                base_name = "Organhalogen tree",
                data_1 = BIOSOLIDS2021_class, 
                name_1 = 'Biosolids',
                base_opts = list(size = 1))

display_subtree(base_tree = oh_tree,
                base_name = "Organhalogen tree",
                data_1 = USGSWATER_class, 
                name_1 = 'USGS Water',
                base_opts = list(size = 1))
```

The argument `base_tree` specifies a `phylo`-class tree object to use as the "base tree" -- the tree to be plotted and have its branches color-coded by list membership. The optional argument `base_name` allows you to specify the title of the plot -- usually this will name or describe the base tree. If `base_name` is not specified, the name of the variable passed to `base_name` will be used by default -- for the above example, this would be "oh_tree". The argument `data_1` specifies a `data.frame` of classified chemicals, for example the output of `classify_inchikeys()`. This `data.frame` must include variables for all taxonomic levels. For ClassyFire, this is "kingdom", "superclass", "class", "subclass", "level5", "level6", ..., "level11". If a level is not used in the classification of a given chemical, that column should have an NA value for that chemical. The optional argument `name_1` allows you to specify the name to be used in the plot legend (here, "Biosolids"). If `name_1` is not specified, the name of the variable passed to `data_1` will be used by default -- for the above example, this would be "BIOSOLIDS2021_class".

 \@ref(fig:subtree-plots) illustrates the locations of the the biosolids and USGS water chemical lists in chemical space. For example, the biosolids list includes more of the "Alkyl halides" group than does the USGS water list, but USGS Water includes "Organobromides", whereas the biosolids list does not.

We can more directly compare the two chemical lists by highlighting them on the same tree. The function `display_subtree()` can also accept a second `data.frame` representing a classified list of chemicals, in argument `data_2`. (There is a corresponding optional `name_2` argument that works the same way as `name_1`.)

```{r subtree-plots-overlap, fig.cap="subtree-plots-overlap", fig.align='center', fig.dim=c(6,4)}
display_subtree(base_tree = oh_tree,
                base_name = "Organohalogen compounds",
                data_1 = BIOSOLIDS2021_class, 
                data_2 = USGSWATER_class, 
                name_1 = 'Biosolids', 
                name_2 = 'USGS Water',
                base_opts = list(size = 1))
```

In \@ref(fig:subtree-plots-overlap), branches and labels are colored based on whether they are members of classifications of one, both, or neither data set. This gives an indication of how the chemical space represented by each data set overlaps and the areas unique to each data set.

### Customizing how branches are highlighted

The user can customize the aesthetics used to highlight branches with argument `subtree_mapping`, which takes a named list . The list elements can be named "color" (or "colour"), "size", and/or "linetype". These are the three aesthetics that `ggtree` understands. Each named element should contain a vector defining the scale for that aesthetic. This vector can have up to four elements. When both `data_1` and `data_2` are defined, the vector elements will be mapped to the following categories, in order: branch is in neither data set; branch is in `data_1` only; branch is in `data_2` only; branch is in both data sets. 

This is easiest to undertand with some examples. The default value of `subtree_mapping` is the following:
```{r}
subtree_mapping = list("color" = c("gray50", #medium gray
                                   "#66C2A5", #blue-green
                                   "#8DA0CB", #purple-blue
                                   "#FC8D62" #red-orange
                                   )
)
```

This means that tree branches are highlighted using only color. Branches in neither dataset are drawn in medium gray. Branches only in data set 1 are drawn in blue-green. Branches only in data set 2 are drawn in purple-blue. Branches in both data sets are drawn in red-orange.

If we wanted to highlight branches using size (line width) and linetype as well as color, we would do the following:

```{r}
display_subtree(base_tree = oh_tree,
                base_name = "Organohalogen compounds",
                data_1 = BIOSOLIDS2021_class, 
                data_2 = USGSWATER_class, 
                name_1 = 'Biosolids', 
                name_2 = 'USGS Water',
                subtree_mapping = list(
                  "color" = c("gray50", #neither dataset
                              "#66C2A5", #dataset 1 only (here, Biosolids)
                              "#8DA0CB", #dataset 2 only (here, USGS Water)
                              "#FC8D62" #both datasets
                  ),
                  "size" = c(0.5, #neither dataset
                             1, #dataset 1 only (here, Biosolids)
                             1.25, #dataset 2 only (here, USGS Water)
                             2 #both datasets
                             ), 
                  "linetype" = c(1,  #neither dataset (solid)
                                 2, #dataset 1 only (here, Biosolids) (dotted)
                                 3, #dataset 2 only (here, USGS Water) (dashed)
                                 4) #both datasets (dot-dashed)
                ) 
)
```

## Highlighting branches of one subtree by their membership in another

It can also be informative to prune the tree to include only branches in one chemical list, and then highlight that pruned subtree's branches by whether they are members of another chemical list. This can be done using the function `prune_and_display_subtree()`, which accepts the same arguments as `display_subtree()`.

Here is the organohalogen tree, pruned to include only the branches represented in `BIOSOLIDS2021_class` (i.e., this is the subtree induced by `BIOSOLIDS2021_class`)

```{r pruned-subtree,  fig.align='center', fig.dim=c(12,12)}
prune_and_display_subtree(base_tree = oh_tree,
                          prune_to = BIOSOLIDS2021_class,
                          prune_name = "Biosolids")
```

Here is the biosolids subtree with branches highlighted to show their membership in the USGS Water list. (Here, we additionally use the grammar of `ggplot2` to plot the legend using thicker lines, so that it is easier to see.)

```{r}
prune_and_display_subtree(base_tree = oh_tree,
                          prune_to = BIOSOLIDS2021_class,
                          prune_name = "Biosolids",
                          data_1 = USGSWATER_class,
                          name_1 = "USGS Water") +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 2)))
```


Note a few things about this diagram. First, some of the branches do not go all the way to the bottom. This occurs when a chemical classification terminates with an internal node -- i.e., the terminal classification is a node that had children in the original tree, but none of the chemicals on the list fall into the classes of any of those children. If you prefer to adjust the branch lengths so that all of the branches go all the way to the bottom, use argument `adjust_branch_length = TRUE` in `prune_and_display_subtree()`.

```{r}
prune_and_display_subtree(base_tree = oh_tree,
                          prune_to = BIOSOLIDS2021_class,
                          prune_name = "Biosolids",
                          data_1 = USGSWATER_class,
                          name_1 = "USGS Water",
                          adjust_branch_length = TRUE) +
  guides(color = guide_legend(override.aes = list(size = 2)))
```


The above diagrams are useful for illustrating which portions of each data set-induced subtree are also represented by labels from the classifications of the other data set. However, these visualizations do not show the *number* of chemicals with a given classification -- i.e., the number of chemicals that populate each branch -- or the number  of chemicals that overlap in each branch. 

```{r}
biosolids_subtree <- prune_tree(tree = oh_tree,
                                prune_to = BIOSOLIDS2021_class,
                                adjust_branch_length = TRUE)
```

If we add chemicals as tips to the tree, it look slike this:
```{r}
new_tree <- bind_entities(tree = biosolids_subtree,
                          data = BIOSOLIDS2021_class,
                          id_col = "PREFERRED.NAME")



display_subtree(new_tree, data_1 = USGSWATER_class, clade_level = NULL)
```



The following diagrams are able to quantify this overlap. We employ the function `leaf_fraction_subtree()` to create this visualization.

```{r}

BIOSOLIDS2021_class <- add_terminal_label(BIOSOLIDS2021_class)
USGSWATER_class <- add_terminal_label(USGSWATER_class)
```

```{r}

biosolids_count <- BIOSOLIDS2021_class %>% dplyr::count(terminal_label) %>% dplyr::rename(n_biosolids = n)
usgs_count <- USGSWATER_class %>% dplyr::count(terminal_label)  %>% dplyr::rename(n_usgs = n)

get_overlap <-  function(termlab){
                    chem_bio <- BIOSOLIDS2021_class[BIOSOLIDS2021_class$terminal_label %in% termlab, "INCHIKEY"]
                    chem_usgs <- USGSWATER_class[USGSWATER_class$terminal_label %in% termlab, "INCHIKEY"]
                    simil <- length(intersect(chem_bio, chem_usgs))/length(union(chem_bio, chem_usgs))
                    simil
                  }

overlapdf <- BIOSOLIDS2021_class %>% dplyr::group_by(terminal_label) %>% dplyr::summarise(overlap = get_overlap(terminal_label))

dat <- get_tree_df(biosolids_subtree)
dat_clade <- dat[dat$level %in% 2,]
```

```{r}

display_subtree(biosolids_subtree,
                clade_level = NULL,
                data_1 = USGSWATER_class,
                name_1 = "USGS Water",
                subtree_mapping = list(size = c(0.5,
                                                1),
                                       color = c("gray50",
                                                 "black"))) +
  geom_fruit(data = biosolids_count,
             geom = geom_tile,
             mapping = aes(y = terminal_label,
                           x = 1,
                           fill = n_biosolids,
                           height =1,
                           width = 10),
             offset = 0,
             pwidth = 0.1) +
  scale_fill_viridis_c(trans = "log10",
                       name = "# chemicals") +
 # ggnewscale::new_scale_fill() +
    geom_fruit(data = usgs_count,
             geom = geom_tile,
             mapping = aes(y = terminal_label,
                           x = 1,
                           fill = n_usgs,
                           height =1,
                           width = 10),
             offset = 0.01,
             pwidth = 0.1) +
  #scale_fill_viridis_c(trans = "log10") +
  ggnewscale::new_scale_fill() +
  geom_fruit(data = overlapdf,
             geom = geom_tile,
             mapping = aes(y = terminal_label,
                           x = 1,
                           fill = overlap,
                           height = 1,
                           width = 10),
             offset = 0.01,
             pwidth = 0.1) +
  scale_fill_viridis_c(option = "magma") +
  theme(legend.position = "left") +
  geom_cladelab(data = dat_clade,
                mapping = aes(node = node,
                              label = Name),
                offset = 40,
                angle = "auto")
```




```{r biosolids-leaf-fraction,  fig.align='center', fig.dim=c(12,8)}
biosolids_leaf_fraction <- leaf_fraction_subtree(data_1 = biosolids_classified, 
                                                 data_2 = usgswater_classified, 
                                                 name_1 = 'Biosolids', 
                                                 name_2 = 'USGS water')
biosolids_leaf_fraction[[1]]
head(biosolids_leaf_fraction[[2]])
```

We also reverse the roles each data set plays to demonstrate the other overlap visualization.

```{r usgs-leaf-fraction,  fig.align='center', fig.dim=c(12,8)}
usgswater_leaf_fraction <- leaf_fraction_subtree(data_1  = usgswater_classified, 
                                                 data_2 = biosolids_classified, 
                                                 name_1 = 'USGS water', 
                                                 name_2 = 'Biosolids')
usgswater_leaf_fraction[[1]]
knitr::kable(usgswater_leaf_fraction[[2]][1:5, ])
#  kbl() %>%
#  kable_styling(bootstrap_options = c("striped", "hover")) %>%
#  kable_classic()
```

The output of this function includes a data frame and a tree visualization. The data frame lists each classification label that shows up as a terminal label in a classification for a chemical in the data set, the number of times it shows up in the given data set. In addition, it also displays the number of the chemicals that terminate with that label, the number that are present in the other data set, and finally the percentage of shared chemicals within the first data set.

The tree visualization then illustrates this by coloring the tips and setting a layer of the same colors around the diagram. The legend shows the percentage of shared chemicals per terminal classification label using a color gradient that corresponds to the tip and layered colors.

We can also plot additional numeric data from a given data set in layers around the subtree induced by the data set. For instance, in the `biosolids_classified` data set, there is a column `AVERAGE_MASS` which gives the average molecular mass for each chemical in the data set. We can group these by their classification and examine boxplots of each set of grouped data. Moreover, we can also include taxonomic levels for which labels will be generated in concentric layers. 

```{r circ-tree-biosolids-mass-tip-color, fig.align='center', fig.dim=c(12,8)}
circ_tree_boxplot(biosolids_classified, 
                  col = 'AVERAGE_MASS', 
                  title = 'Biosolids', 
                  tippoint_boxplot = TRUE, 
                  layers = c('kingdom', 'superclass'))
```

If we want to suppress the tippoint and boxplot colors, we can easily do so.

```{r circ-tree-biosolids-mass-no-tip-color, fig.align='center', fig.dim=c(12,8)}
circ_tree_boxplot(biosolids_classified, 
                  col = 'AVERAGE_MASS', 
                  title = 'Biosolids', 
                  layers = c('kingdom', 'superclass'))
```

# Similarity between trees

The tree visualization functions we have demonstrated thus far have focused on a visual exploration of chemical space and how each data set spreads through it. We have seen how we can examine the overlap in chemical space between data sets and how to examine more closely the subtrees representing each data set. However, there are some more quantitative methods of exploring these overlaps that we have yet to cover.

The notion of similarity within ontologies and taxonomies has been an area of interest across a variety of disciplines. These aim to compare pairs of nodes in a tree with each other to gain insight on how they relate to each other. Some of these methods involve examining just the pair of paths from the root of the tree to each of the nodes, while others may examine information more intrinsic to each node. While there is a lot to discuss and explore in the area of similarity measures, we will postpone that to the future and focus on how to use these similarity measures. The main points of similarity measures we will highlight and then demonstrate visualizations that leverage them.

Jaccard similarity examines the path from the root to each node in the pair of nodes, and relates these paths to the shared path (which may possibly be just the root). We can relate these in the following expression $$\text{sim}_{\text{Jac}}(v_1, v_2) = \frac{l(mrca(v_1, v_2))}{l(v_1) + l(v_2) - l(mrca(v_1, v_2))}$$ where $l(v_i)$ denotes the length of the root-to-node path for node $v_i$ and $mrca(v_i, v_j)$ denotes most recent common ancestor for nodes $v_i$ and $v_j$, the shared node in the root-to-nodes paths for nodes $v_i$ and $v_j$ furthest from the root (and in some cases possibly the root). This notion of similarity is calculated using the function `general_Jaccard_similarity()`, which takes as parameters a tree and two labels and returns the Jaccard similarity of the two labels within the tree. We exclude the case when the root is one of the nodes being compared. Note, if $v_i = v_j$, then $\text{sim}_{\text{Jac}}(v_i, v_j) = 1$.

Some trees may come with a probability distribution attaching probabilities to each node such that the sum of all node probabilities is 1. In the case that a tree does not have such a distribution, we can still derive a node-specific value for each node in the tree. In fact, we can look at the number of descendants a node has and compare this with the total number of nodes in the tree. We would also like for tips to have a higher value than their ancestors, with the root having the minimum value. One way we can do this is by comparing the number of nodes in a given subtree with a specified node as the root of the subtree with the total number of nodes, evaluating a monotonically decreasing function on these values, and examining their ratio. In particular, for node $v_i$, define $$\text{IC}(v_i) = 1 - \frac{\log(1 + |\text{V}_{v_i}|)}{\log(|V|)}$$ where $V_{v_i}$ denotes the descendants of node $v_i$ and $|V|$ is the total number of nodes in the tree. In the case that $v_i$ is a tip, it has no descendants so $\text{IC}(v_i) = 1 - \frac{\log(1)}{\log(|V|)} = 1$. If $v_i$ is the root, then $$\text{IC}(v_i) = 1 - \frac{\log(1 + |\text{V}_{v_i}|)}{\log(|V|)} = 1 - \frac{\log(|V|)}{\log(|V|)} = 0.$$ Also note that if $v_i$ is an ancestor of $v_j$, then $|\text{V}_{v_i}| > |\text{V}_{v_j}|$ and since the function $f(x) = 1 - \frac{\log(1 + x)}{N}$ (for $N > 0$) is monotonically decreasing for $x > 0$, it follows that $\text{IC}(v_i) < \text{IC}(v_j)$. Hence, the function above fits the desired properties. 

One way to frame the concept of information content is the idea that the less likely a node appears in a generic path starting from the root and ending at an arbitrary node, the more information it tells when we know the node is one a path given to us. So for instance, the only path a tip can exist on is the unique path connecting it with the root. However, for an ancestor of a tip, there are more paths that include this node, so knowing the ancestor is on a path gives less information about what the path might be. Since every path starting at the root includes the root, knowing the root is on the path yields no information.

To generate the information content for a tree, we can use the function `attach_information_content()` which takes in a tree as the only required parameter. This function also includes the number of descendants, children, and the level for each node. Observe that all of the tips have 0 descendants and an information content of 1, given by the `log_descendants` column. The root has an information content of 0. The remaining two nodes have the desired inequality in the values of their information content as it relates to the number of descendants.

Once an information content value is established for each node, we can then use similarity measures that rely on information content to compare nodes.

The first such method is called Resnik similarity. This is defined for two nodes $v_i$ and $v_j$ as $$\text{sim}_{\text{res}}(v_1, v_2) = \text{IC}(mrca(v_i, v_j)).$$ Observe that this is symmetric and when $v_i = v_j$ just returns the information content of the node itself. Note that for nodes that are not tips, their self-similarity is not always equal to 1. This implicitly encodes the fact that such a node tells less information than more specific nodes (nodes with fewer descendants). Also, since the information content of the root is zero, any pair of nodes containing the root will return a similarity value of zero.

There are additional similarity measures that build off of Resnik similarity. These will in fact return a value of 1 for self-similarity of nodes unlike in Resnik.

The next method is Lin similarity. This resembles Jaccard similarity in that it is a ratio a value derived from the most recent common ancestor of a pair of nodes with values derived from the nodes themselves. In particular, we define $$\text{sim}_{\text{lin}}(v_i, v_j) = \frac{2 \times \text{sim}_{\text{res}}(v_i, v_j)}{\text{IC}(v_i) + \text{IC}(v_j)}.$$ Since the numerator is a scaled form of Resnik similarity, a pair of nodes with the root as their most recent common ancestor will have a value of zero for their Lin similarity. However, unlike in Resnik similarity, if $v_i = v_j$, then $2 \times \text{sim}_{\text{res}}(v_i, v_i) = 2 \times \text{IC}(v_i)$, so the self-similarity value is equal to 1. Another thing to note is that for a pair of nodes with at least one not equal to the root, $$0 < \text{IC}(v_i) + \text{IC}(v_j) \leq 2$$ so $$1 \leq \frac{2}{\text{IC}(v_i) + \text{IC}(v_j)}$$ from which it follows that $$\text{sim}_{\text{res}}(v_i, v_j) \leq \text{sim}_{\text{Lin}}(v_i, v_j).$$ 

We define the self-similarity of the root to be 1 to reflect the fact that in Lin similarity, self-similarity is equal to 1. This keeps in tact the relation above between Resnik similarity and Lin similarity.

An alternative take on normalizing the similarity value for a pair of nodes takes advantage of the inequality $$2 \times \text{sim}_{\text{res}}(v_i, v_j) \leq \text{IC}(v_i) + \text{IC}(v_j).$$ Taking the difference yields The following inequality $$0 \leq \text{IC}(v_i) + \text{IC}(v_j) - 2 \times \text{sim}_{\text{res}}(v_i, v_j) \leq 2.$$ Dividing this inequality by 2 restricts the values the middle expression can take to the interval $[0,1]$. However, we want the similarity to be equal to 1 if $v_i = v_j$ and the expression above returns a value of 0 instead. The solution is to take the difference of 1 and this expression, yielding $$\text{sim}_{\text{JiangConrath}}(v_i, v_j) = 1 - \frac{\text{IC}(v_i) + \text{IC}(v_j) - 2 \times \text{sim}_{\text{res}}(v_i, v_j)}{2}.$$ This was developed by Jiang and Conrath and is thus named. 

Things to note are that when the most recent common ancestor for a pair of nodes $v_i$ and $v_j$ is the root, this does not necessarily return a value of zero. In fact, rewriting the expression for this similarity measure, we see that it is equal to $$\text{sim}_{\text{JiangConrath}}(v_i, v_j) = \text{sim}_{\text{res}}(v_i, v_j) + \frac{2 - (\text{IC}(v_i) + \text{IC}(v_j))}{2} \geq \text{sim}_{\text{res}}(v_i, v_j)$$ since $$\text{IC}(v_i) + \text{IC}(v_j) \leq 2.$$ One thing this reflects is that if a pair of such nodes represents a large portion of the tree based on their descendants, they are more likely to be closer to the root and thus more related to each other. 

When comparing a pair of nodes that are tips, say $v_i$ and $v_j$, then observe that since $$\text{IC}(v_i) = \text{IC}(v_j) = 1,$$ $$\text{sim}_{\text{res}}(v_i, v_j) = \text{sim}_{\text{lin}}(v_i, v_j) = \text{sim}_{\text{JiangConrath}}(v_i, v_j).$$ Thus, the three similarity measures all agree on pairs of tips but diverge otherwise.

Now, the function `attach_information_content()` generates information content for an input tree, and the functions `general_Jaccard_similarity()`, `general_Resnik_similarity()`, `general_Lin_similarity()`, `general_JiangConrath_similarity()` all can be used to compare a pair of nodes on a given tree. Moreover, if one wants to compute the similarity for all pairs, the function `generate_similarity_matrix()` will do so for a given tree and similarity measure function. The computation is lengthy for the chemont tree and so these matrices have been previously computed and stored. They are accessible as `chemont_jaccard`, `chemont_resnik_IC_SVH`, `chemont_lin_IC_SVH`, and `chemont_jiangconrath_IC_SVH`.

Now, we move to using these in visualizations.

The function `generate_heatmap()` will take in a pair of data sets and compare the induced subtrees using similarity measures. In the example below, we use the Jaccard similarity values of the ChemOnt tree, with rows representing classifications from `usgswater_classified`, columns representing classifications from `biosolids_classified`. In this diagram, we have specified for there to be 9 row and 9 column clusters based on the hierarchical clustering of the heatmap.

```{r heatmap-biosolids-usgs, fig.align='center', fig.dim=c(6,4)}
biosolids_usgs_ht <- generate_heatmap(tree_object = chemont_tree, 
                                      matrix = chemont_jaccard, 
                                      row_data = usgswater_classified, 
                                      column_data = biosolids_classified, 
                                      row_split = 9L, column_split = 9L, 
                                      row_title = 'USGS Water', 
                                      column_title = 'Biosolids', 
                                      name = 'Jaccard Similarity')
biosolids_usgs_ht
```

Observe that in row cluster 2 and column cluster 2, there appears to be a lot of high similarity values. Also note that in row cluster nine, column cluster 8, there are both high similarity values and low similarity values. We analyze these clusters by visualizing the labels associated to each data set in these clusters.

```{r rc-cluster-2-2, fig.align='center', fig.dim=c(12,8)}
generate_tree_cluster(tree = chemont_tree, tree_object = chemont_tree, 
                      htmap = biosolids_usgs_ht, row_cluster = 2, 
                      column_cluster = 2, row_name = 'USGS Water', 
                      column_name = 'Biosolids', isolate_subtree = TRUE)
```

Observe that only the superclass 'Benzenoids' is represented. In the second diagram, we prune away all extraneous superclass branches. Notice that the labels present in the data sets are indicated by points, colored by whether they are found in one or both data sets.




```{r rc-cluster-9-8, fig.align='center', fig.dim=c(12,9)}
generate_tree_cluster(tree = chemont_tree, tree_object = chemont_tree, 
                      htmap = biosolids_usgs_ht, row_cluster = 9, 
                      column_cluster = 8, row_name = 'USGS Water', 
                      column_name = 'Biosolids', isolate_subtree = TRUE)

```

In this pair of diagrams, we observe that there are several superclasses represented. In fact, there are labels from the USGS Water data set present in all superclasses highlighted, though the labels from the biosolids data set are only found within the "Organic nitrogen compounds" superclass. In the second diagram, we can observe this more closely. 


